# LJC 三国群英传 · 后端最终对齐版需求说明（V2.8 · 兵为个体堆栈模型）
> **读者对象：后端同学**  
> 你不需要看任何旧文档或聊天记录  
> 只要照本文实现，战斗与养成口径就不会跑偏  
>  
> 本版关键改动：  
> - ✅ **兵是个体**（不是一个总血条池）  
> - ✅ 兵以“单位堆栈（Stack）”表达：`count + unit_hp + front_hp`  
> - ✅ 伤害先结算“死了几个兵”，人数变化影响下一阶段输出  
> - ✅ 允许伤害溢出：一个兵种被打空后，剩余伤害按规则流向下一个兵种  
> - ✅ 禁止随机扣单兵血量（必须可复算可验证）  
> - ✅ 主动技能核心是“打对方英雄造成伤害”，无英雄时才打兵（且按固定规则选兵）

---

## 0. 游戏核心循环（无大地图）
- 大厅：招兵（金币）→ 强化装备 → 镶嵌宝石 → 学技能（技能书覆盖）→ 选关（主线/爬塔）
- 战斗：**回合制进行**（不是一次性结算）
- 结算：胜 / 负 / 平（回合上限）→ 返还伤兵（胜多败少）→ 掉落（爬塔掉设计图）→ 进度解锁

**明确禁止**：坐标、行军时间、定时到达、世界地图队列。

---

## 1. 兵种与克制（固定）
### 1.1 三基础兵种
- 步兵 INF
- 弓兵 ARC（回合内先手阶段先打）
- 骑兵 CAV

### 1.2 克制关系（三角循环）
- 步兵克弓兵
- 弓兵克骑兵
- 骑兵克步兵

### 1.3 克制倍率（可配置建议）
- 对被克制目标：伤害 ×1.25
- 被克制时输出：伤害 ×0.75

> 克制主要作用于：兵打兵。  
> 英雄打英雄暂不吃三角克制（未来可扩展英雄克制表）。

---

## 2. 特种兵（四类固定）
特种兵数量稀少，作用是“放大基础兵种/英雄”，不是替代基础兵。

四类：
1) 强化步兵型（强化 INF）  
2) 强化弓兵型（强化 ARC）  
3) 强化骑兵型（强化 CAV）  
4) 强化英雄型（强化 HERO，例如每5个加英雄ATK）

实现建议：特种兵效果配置化（effect_json / 表驱动），战斗算法可以后续逐步落地，但必须在战斗会话状态里保留“我方携带了哪些特种兵及数量”的信息。

---

## 3. 装备与宝石（统一采用“累加型成长”）
### 3.1 累加型成长公式（装备强化 & 宝石等级共用）
给定初始值 X，等级 n：
- 总加成 = X × (1 + 2 + … + n) = X × n × (n + 1) / 2

示例（X=10）：
- +0: 10
- +1: 20
- +2: 40
- +3: 70
- +4: 110

### 3.2 强化成功率 & 失败惩罚
- +1~+3：100%
- +4 起：成功率递减（策划表配置）
- 失败惩罚：**降 1 级**（不碎装备）

---

## 4. 英雄（武将）与性格（Personality）
### 4.1 英雄解锁（非抽卡）
每国家 3 名英雄：第 1 / 5 / 10 关解锁。共 12 英雄。

### 4.2 性格当前集合（可扩展）
- **狂战**：deal_mult↑ taken_mult↑（输出更高但更脆）
- **冷静**：无增减（1000/1000）
- **军医**：战后救治率 rescue_rate_bonus↑
- **死战**：HP ≤ 10% 倾向死战（last_stand_bias 很高）
- **谨慎**（可选）：倾向撤退（last_stand_bias 负向）

> 性格只影响：伤害倍率、承伤倍率、撤退/死战倾向、战后救治倾向、打将策略偏置。

---

## 5. 回合制战斗：会话模型（battle_sessions）
### 5.1 核心理念
战斗不是“后端算完结果前端播放”，而是：
- 后端维护一个**进行中的战斗会话**
- 前端每回合提交行动（是否释放主动技能）
- 后端推进回合并返回本回合战斗事件

### 5.2 battle_sessions 的职责（推荐）
- 1玩家=1会话（同一时间不能多场战斗）
- 字段建议：
  - user_id
  - battle_id
  - current_turn
  - context_json（完整战斗状态）
  - updated_at

### 5.3 context_json 必须包含的状态（最低集合）
- 我方英雄：hp、max_hp、speed、cd_remaining、撤退标记、死战标记
- 敌方英雄：同上
- 我方兵力堆栈（每兵种）：count、unit_hp、front_hp
- 敌方兵力堆栈：同上
- 我方特种兵数量（四类）
- 敌方特种兵数量（四类）
- 随机种子 seed（用于可复算与战报）
- 模式信息：story/tower，关卡号等

---

## 6. 本版核心：兵为“个体堆栈（Stack）”模型（必须照做）
### 6.1 为什么必须是“个体”
你（策划）明确要求：
- 如果我方弓兵造成伤害导致敌方弓兵死了一半
- 那么敌方弓兵下一阶段只能用剩下的数量出手
- 伤害不是打一个总血条，而是“打死几个兵”

所以：**兵必须按“单位死亡”结算。**

### 6.2 兵堆栈结构（每个兵种一个堆栈）
对每个兵种维护：
- `count`：当前存活数量（整数）
- `unit_hp`：该兵种每个单位的最大HP（来自 troop_template.base_hp）
- `front_hp`：当前“最前面的那 1 个单位”的剩余HP（1..unit_hp）

说明：
- 你不需要存 100 个对象
- 但结算上等价于“每个兵都是个体”

### 6.3 伤害结算必须遵循：先结算死亡数量，再决定溢出
给定一个堆栈 stack 与伤害 dmg：
1) 先扣 front_hp，判断是否打死 front 这个单位  
2) front 死亡则 count-1，front_hp 重置为 unit_hp  
3) 使用整除批量杀死若干完整单位（避免循环 100 次）  
4) 若仍有剩余伤害，则打到新的 front_hp  
5) 若 count 被打到 0，则剩余伤害 **溢出到下一个目标兵种堆栈**

### 6.4 推荐伪代码（后端可直接照写）
```java
// Stack: {long count, long unitHp, long frontHp}
// return: remaining damage (overflow) that should be applied to next stack
long applyDamage(Stack s, long dmg) {
    if (dmg <= 0 || s.count <= 0) return dmg;

    // 1) hit current front unit
    if (dmg < s.frontHp) {
        s.frontHp -= dmg;
        return 0;
    }
    dmg -= s.frontHp;
    s.count -= 1;
    if (s.count <= 0) { s.frontHp = 0; return dmg; }
    s.frontHp = s.unitHp;

    // 2) batch kill full units
    long kill = Math.min(s.count, dmg / s.unitHp);
    s.count -= kill;
    dmg -= kill * s.unitHp;
    if (s.count <= 0) { s.frontHp = 0; return dmg; }

    // 3) remaining damage goes into new front unit
    if (dmg > 0) {
        s.frontHp = s.unitHp - dmg;
        return 0;
    }
    return 0;
}
```

---

## 7. 攻击目标系统（固定，不允许随机）
### 7.1 目标类型
- HERO（敌方英雄：存在且未撤退/未死亡）
- TROOP_STACK（敌方兵力：按 INF/ARC/CAV/ELITE_* 分堆栈）

### 7.2 总规则（必须）
- 禁止随机扣某个兵的血
- 所有目标选择必须固定可复算
- 兵的伤害必须按堆栈结算“死了几个”
- 伤害允许溢出，溢出流向必须固定

---

## 8. 英雄普攻目标规则（最终版）
### 8.1 若敌方 HERO 存在
- 英雄普攻 → 命中敌方 HERO

### 8.2 若敌方 HERO 不存在（已撤退或已死亡）
英雄普攻 → 攻击敌方兵堆栈，并按固定优先级选择目标堆栈：
1) 特种兵堆栈（先拆核心加成）
2) 弓兵 ARC（削对方先手）
3) 骑兵 CAV（高威胁输出）
4) 步兵 INF（肉盾最后）

> 优先级写死在代码或配置表，但必须固定。

### 8.3 英雄打兵时的溢出规则
若目标堆栈被打空且仍有剩余伤害：
- 按上述优先级继续寻找下一个非空堆栈吃伤害
- 直到伤害耗尽或所有兵堆栈清空

---

## 9. 兵的出手顺序与攻击规则（回合内）
### 9.1 出手顺序（固定）
- 弓兵 ARC phase：先出手
- 再 INF/CAV phase：其余兵种出手（你后续可固定 INF→CAV 或 CAV→INF，本版建议 INF→CAV）

### 9.2 兵的攻击目标（固定）
兵默认攻击：敌方兵堆栈。目标选择规则：

**第一优先：克制目标堆栈**
- INF 优先打 ARC
- ARC 优先打 CAV
- CAV 优先打 INF

若克制目标堆栈为空，则按威胁优先顺序打：
1) 特种兵堆栈
2) 弓兵 ARC
3) 骑兵 CAV
4) 步兵 INF

### 9.3 兵攻击造成伤害后的“死亡结算”
- 兵攻击伤害进入 `applyDamage(stack, dmg)`
- 结算后堆栈 count 变化
- 下一阶段该兵种输出应基于新的 count（这就是“兵是个体”的意义）

---

## 10. 主动技能（Active Skill）最终规则：技能=伤害技能
### 10.1 主动技能的本质
- 主动技能 = 造成伤害（不是 buff）
- 有 CD（回合）
- 玩家在回合内选择是否释放
- 英雄撤退后不能释放技能

### 10.2 主动技能默认目标（严格）
1) 若敌方 HERO 存在：技能必定命中敌方 HERO  
2) 若敌方 HERO 不存在：技能命中敌方兵堆栈（按规则选堆栈）

### 10.3 技能打兵时的目标堆栈选择（固定）
统一采用与英雄普攻相同的优先级：
1) 特种兵堆栈
2) ARC
3) CAV
4) INF

并且允许溢出：打空一个堆栈后剩余伤害按优先级流向下一个堆栈。

### 10.4 技能效果字段建议（effect_json）
- damage_rate（百分比，如 150 表示 150%）
- hits（段数，默认 1）
- target_mode（AUTO / HERO_ONLY / TROOP_ONLY）
- splash（溅射比例，可选）
- note（前端表现标签，可选）

---

## 11. 被动技能（Passive Skill）
被动技能允许存在，但定位为：
- 小倍率常驻（≤20%）
- 节奏触发（低血、回合开始、战斗开始）
- 战后类（救治）

原则：不要做成“叠一堆数值把人秒了”。

---

## 12. 撤退 / 死战（英雄 HP ≤ 10% 时触发）
### 12.1 触发
当英雄 HP ≤ 10% 时触发性格判定：撤退 or 死战。

### 12.2 后果（策划已定）
- 撤退：我方士兵整体血量 -20%（可理解为混乱/士气崩）
- 死战：士兵整体血量 -40%，且攻击力略降（倍率配置）

### 12.3 撤退后规则
- 英雄不再出手
- 英雄不再可被选为目标
- 英雄技能不可释放

---

## 13. 结算与返还伤兵
- 胜利：伤兵返还更多（例如阵亡的 50%）
- 失败：伤兵返还更少（例如阵亡的 10%）
- 平局：建议 20%（或按失败）

并叠加 personality 的 rescue_rate_bonus。

---

## 14. 掉落与制作图
- 设计图（blueprint）主要在“爬塔模式”掉落
- 制作：有概率成功，失败碎（消耗材料与金币）
- 强化失败：只掉级不碎

---

## 15. 后端优先实现清单（你要求“先大厅后战斗算法”）
先把这些做完再写复杂战斗伤害公式：
- 四国进度链：初始选国 → 通关王城（10关）解锁下一国 → 四国全解锁后爬塔开放
- 招兵：金币购买，直接改 user_troops（原子事务）
- 装备：掉落/制作/强化（概率失败掉级）/穿戴
- 宝石：产出/镶嵌（不可拆）/5合1升级
- 技能：默认技能、技能书学习覆盖、记录 learn_log
- 战斗会话：battle_sessions 的创建、推进回合、维护 CD/HP/撤退标记
- 伤害算法可以先简化，但：**目标规则 + 堆栈结算必须按本文固定口径**

---

## 16. 给后端的最终一句话（可直接贴任务单）
> 实现回合制战斗会话模型技能为伤害技能默认命中敌方英雄敌方无英雄才按固定优先级攻击兵堆栈兵为个体用count unit_hp front_hp的堆栈模型结算伤害先算死亡数量人数变化影响下一阶段输出允许伤害溢出并按优先级流向下一个堆栈禁止随机扣单兵血量兵种克制为步弓骑三角循环特种兵分四类装备宝石用累加型成长强化失败降一级不碎先完成大厅养成与进度链战斗公式可后续细化但会话与堆栈口径必须严格按本文
