
# 战斗模块前端企划 V1.0（两阶段：武将 Solo → 小兵战；小兵伤害按 roll 比例分流打武将）

## 0. 目标与原则（前端看这里就够）

前端职责只有两件事：

1. **发回合指令**：阶段 1 是否释放技能（`castSkill`）
    
2. **播放后端回传的事件流 events**：按顺序播动画、飘字、更新 UI 状态
    

重要原则：

- **前端不计算战斗结果**，不做任何随机
    
- 所有随机（roll 0–100）由后端产生并写进事件
    
- 前端只负责“展示 roll 结果造成了哪些分流伤害”
    

---

## 1. 核心规则摘要（用于前端文案、UI提示）

### 1.1 特种兵规则（新）

- 每个国家只有 **1 种特种兵**
    
- 战斗中只会出现双方各自国家的特种兵（数量可能为 0）
    
- 解锁：必须攻克对方国家，才解锁对方国家武将和特种兵
    

> 前端需要展示：特种兵“国家归属 + 数量”，不需要展示 4 类。

### 1.2 两阶段规则

- **阶段 1：武将 Solo（仅武将互殴）**
    
- **阶段 2：小兵战（双方小兵交战，且阶段 1 活着的武将参与阶段 2）**
    

### 1.3 小兵攻击分流（拆分比例，已确认）

对每个出手兵种都会 roll 一次 `0–100`：

- roll = X 表示：该兵种本次攻击里
    
    - X% 的伤害打敌方武将（若武将仍可战斗）
        
    - (100-X)% 的伤害打敌方小兵堆栈
        
- 对方有几个兵种在场，就会有几次 roll（每个兵种一次）
    

### 1.4 胜负判定（已确认）

任意时刻，只要出现“一方没有任何能战斗的单位”，立刻结束：

- **能战斗单位 =（武将未死未撤退）或（任意兵堆栈 count>0）**
    
- 例：阶段 1 武将撤退，阶段 2 小兵全死 → 这一方算输
    

> 前端不要自行判断，后端会在事件里直接给 `BATTLE_END`。

---

## 2. 前端页面结构与 UI 组件建议

### 2.1 页面分区

1. 顶部栏：回合数、阶段标签、暂停/加速按钮
    
2. 中部战场：
    
    - 我方武将立绘 + 血条（阶段 2 可参与）
        
    - 敌方武将立绘 + 血条
        
    - 双方兵线（3 个基础兵种 INF/ARC/CAV + 1 个特种兵显示位）
        
3. 底部操作区：
    
    - 阶段 1：技能按钮（亮/灰/冷却数字）
        
    - 阶段 2：默认隐藏或置灰（只播）
        

### 2.2 兵种 UI 显示（推荐）

每方最多 4 行：

- 特种兵（国家图标 + count）
    
- ARC（弓）
    
- CAV（骑）
    
- INF（步）
    

每一行展示：

- count（存活数）
    
- frontHp 进度条（可选，进阶；不做也行）
    
- “本回合出手提示/受击提示”（短闪烁）
    

---

## 3. 前端与后端的接口约定（你可以直接发给前端）

### 3.1 开始战斗

`POST /battle/start`

入参（示例）：

```json
{
  "mode": "story",
  "stageId": 12,
  "myNation": "WEI",
  "myHeroId": 101,
  "myTroops": { "INF": 120, "ARC": 80, "CAV": 60 },
  "mySpecialTroopCount": 12
}
```

返回（关键字段）：

- `battleId`
    
- `turn`
    
- `phase`：`HERO_SOLO` 或 `TROOP_WAR`
    
- `state`：完整初始状态（武将、兵堆栈、特种兵）
    

---

### 3.2 推进回合（核心）

`POST /battle/turn`

入参：

```json
{
  "battleId": "B20260211_001",
  "castSkill": true
}
```

返回：

- `turn`
    
- `phase`
    
- `events[]`：本回合事件脚本（前端按顺序执行）
    
- `stateDelta` 或 `state`：更新后的状态（二选一都行，建议直接给 stateDelta + 关键快照）
    

> 前端实现上：**只信 events 驱动动画**，状态以最后返回为准。

---

## 4. 事件流（events）规范：前端渲染器只需要支持这些类型

下面是“必须支持”的事件类型清单。你前端可以写一个 `switch(type)` 的事件播放器。

### 4.1 通用字段

每个 event 都建议包含：

- `seq`：事件序号（保证排序）
    
- `type`
    
- `side` / `actorSide`：`my` / `enemy`
    
- `timestamp`（可选）
    

---

## 5. 两阶段详细流程（前端播放顺序）

# 阶段 1：HERO_SOLO（武将单挑）

### 5.1 回合开始（可选事件）

```json
{ "type": "TURN_START", "turn": 1, "phase": "HERO_SOLO" }
```

前端表现：回合数+1，阶段标签保持“武将单挑”。

---

### 5.2 玩家技能（可选）

若本回合 `castSkill=true` 且后端判定允许释放：

```json
{
  "type": "HERO_SKILL",
  "actorSide": "my",
  "target": { "kind": "HERO", "side": "enemy" },
  "skillId": 2001,
  "damage": 620,
  "cdSetTo": 3
}
```

紧跟扣血：

```json
{ "type": "HERO_HP_CHANGE", "side": "enemy", "delta": -620, "hpAfter": 4180 }
```

前端表现：

- 播技能动画（按 skillId 选特效）
    
- 飘字 620
    
- 更新敌方武将血条
    
- 更新我方技能按钮进入 CD 显示“3”
    

---

### 5.3 武将普攻（固定）

例：我方普攻、敌方普攻：

```json
{ "type": "HERO_ATTACK", "actorSide": "my", "damage": 300 }
{ "type": "HERO_HP_CHANGE", "side": "enemy", "delta": -300, "hpAfter": 3880 }

{ "type": "HERO_ATTACK", "actorSide": "enemy", "damage": 280 }
{ "type": "HERO_HP_CHANGE", "side": "my", "delta": -280, "hpAfter": 4660 }
```

---

### 5.4 撤退/死亡/阶段切换

如果武将撤退：

```json
{ "type": "HERO_RETREAT", "side": "my", "reason": "personality_trigger" }
```

如果武将死亡：

```json
{ "type": "HERO_DEAD", "side": "enemy" }
```

如果进入阶段 2：

```json
{
  "type": "PHASE_CHANGE",
  "from": "HERO_SOLO",
  "to": "TROOP_WAR",
  "survivor": { "myHeroCanFight": true, "enemyHeroCanFight": false }
}
```

前端表现：

- 阶段切换时：UI 大标题切换
    
- “活下来的武将”保持站场；撤退/死亡的武将置灰并打上“撤退/阵亡”标记
    

---

# 阶段 2：TROOP_WAR（小兵交战 + roll 分流打武将）

## 6. 阶段 2 每回合事件结构（推荐模板）

一个回合通常长这样：

1. TURN_START
    
2. 多段 TROOP_ATTACK（按出手顺序：弓 → 步 → 骑；每个兵种一次）
    
3. 可能穿插 HERO_ATTACK（如果阶段 2 允许武将普攻，你可以让后端继续发）
    
4. TURN_END
    
5. 可能 BATTLE_END
    

> 关键：**每个兵种出手必带 rollToHero**，让前端可解释分流。

---

## 7. TROOP_ATTACK 事件（分流拆分比例：前端必须支持）

### 7.1 事件 1：兵种开始攻击（包含 roll）

```json
{
  "type": "TROOP_ATTACK",
  "actorSide": "enemy",
  "attackerTroopType": "ARC",
  "rollToHero": 20,
  "damageTotal": 1000,
  "damageToHero": 200,
  "damageToTroops": 800,
  "note": "20% damage diverted to hero"
}
```

前端表现（建议）：

- 在攻击开始时，UI 弹一条小提示：  
    “敌方弓兵：roll 20 → 20% 攻击武将”
    
- 动画上：一部分弹道飞向武将，一部分飞向兵线（做不出来也没关系，至少分两段飘字）
    

---

### 7.2 事件 2：武将受伤（如果 damageToHero > 0 且目标武将可战斗）

```json
{ "type": "HERO_HP_CHANGE", "side": "my", "delta": -200, "hpAfter": 4460 }
```

前端表现：武将被击中、扣血飘字 200。

> 如果我方武将已撤退/死亡，后端应该把 damageToHero=0 或直接不发这条，前端无需处理异常。

---

### 7.3 事件 3：兵堆栈变化（damageToTroops 结算结果）

```json
{
  "type": "TROOP_STACK_CHANGE",
  "side": "my",
  "troopType": "CAV",
  "killed": 6,
  "before": { "count": 60, "frontHp": 120 },
  "after":  { "count": 54, "frontHp": 40 }
}
```

前端表现：

- 更新该兵种 count
    
- 受击闪烁
    
- 可选：显示 “-6” 的死亡提示
    

> 注意：troopType 可能是 INF/ARC/CAV/SPECIAL（看你是否让特种兵单独成为一个堆栈）

---

## 8. 阶段 2 的“多兵种多次 roll”展示规则

因为你要求“对方有几个兵种就 roll 几次”，所以前端应该：

- 每出现一次 `TROOP_ATTACK` 就展示一次 roll 结果
    
- 一回合可能出现 2～4 次 roll（取决于还有几个兵种 count>0）
    

---

## 9. 结束判定与结算展示

### 9.1 BATTLE_END 事件（后端最终裁决）

```json
{
  "type": "BATTLE_END",
  "result": "LOSE",
  "reason": "no_fighting_units",
  "settlement": {
    "woundedReturnRate": 0.1,
    "troopsReturned": { "INF": 3, "ARC": 0, "CAV": 1 },
    "drops": []
  }
}
```

前端表现：

- 弹结算面板：胜/负/平
    
- 展示原因文案（映射 reason）
    
    - `no_fighting_units`：已无可战斗单位
        
    - `enemy_cleared`：敌军全灭
        
    - `turn_limit`：回合上限
        
- 展示伤兵返还、掉落、按钮（重开/下一关/返回）
    

---

## 10. 前端实现建议：事件播放器（非常关键）

建议前端写一个统一的“事件队列播放器”：

- 输入：events[]
    
- 输出：依次执行动画与 UI 更新
    
- 支持倍速：1x / 2x / 4x（改变每个事件间 delay）
    
- 支持跳过：直接把本回合 events 播完只刷新最终 state
    

播放节奏建议（不追求花哨也能看懂）：

- 攻击事件（技能/普攻/兵攻）之间间隔 250–400ms
    
- 同一个 TROOP_ATTACK 内部：先播武将扣血，再播兵堆栈变化
    

---

## 11. 前端最容易踩坑的点（我提前写死规则）

1. **不要自己 roll**，也不要自己算 20%
    
    - 后端会给 `damageToHero` / `damageToTroops`
        
2. **不要自己判定胜负**
    
    - 只要收到 `BATTLE_END` 就结束
        
3. **阶段切换只看 PHASE_CHANGE**
    
    - 不要靠血条为 0 猜测进入阶段 2
        
4. **同一回合可能出现多个 TROOP_ATTACK**
    
    - 你必须按 events 顺序播，不然画面会乱
        

---

